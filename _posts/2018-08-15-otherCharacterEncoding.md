---
layout: post
title: "编码格式简介(ANSI、GBK、GB2312、UTF-8、GB18030和 UNICODE)"
date: 2018-08-15 14:15:00 +0800
categories: other
description: "编码格式简介(ANSI、GBK、GB2312、UTF-8、GB18030和 UNICODE)"
tag: other
---

> 编码一直是让新手头疼的问题，特别是 GBK、GB2312、UTF-8 这三个比较常见的网页编码的区别，更是让许多新手晕头转向，怎么解释也解释不清楚。但是编码又是那么重要，特别在网页这一块。如果你打出来的不是乱码，而网页中出现了乱码，绝大部分原因就出在了编码上了。此外除了乱码之外，还会出现一些其他问题（例如：IE6 的 CSS 加载问题）等等。我写本文的目的，就是要彻底解释清楚这个编码问题！如果你遇到了类似的问题，那就要仔细的看看这篇文章。

### ANSI、GBK、GB2312、UTF-8、GB18030和 UNICODE

这几个编码关键词是比较常见的，虽然我把我们放在了一起说，但并不意味这这几个东西是平级的关系。本部分的内容，引用自网络略有修改，不知原文出处，故无法署名。

很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物，他们把这称为”字节”。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去，他们就把这机器称为“计算机”。

开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上 0x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为”控制码”。

他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做**ANSI**的“**Ascii**”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的**ASCII**方案来保存英文文字。

后来计算机发展越来越广泛，世界各国为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了 最后一个状态255。**从128到255这一页的字符集被称”扩展字符集”**。但是原有的编号方法，已经再也放不下更多的编码。

等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。于是中国人就自主研发，把那些127号之后的奇异符号们直接取消掉。规定：**一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（称之为高字节）从0xA1到0xF7，后面一个字节（称之为低字节）从0xA1到0xFE**，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，**连在 *ASCII* 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符**，而原来在127号以下的那些就叫”半角”字符了。

中国人民看到这样很不错，于是就把这种汉字方案叫做 “**GB2312**”。**GB2312是对ASCII的中文扩展**。

但是中国的汉字太多了，后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为GBK标准，**GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号**。后来少数民族也要用电脑了，于是我们再扩展，**又加了几千个新的少数民族的字，GBK 扩成了 GB18030**。从此之后，中华民族的文化就可以在计算机时代中传承了。

因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码。当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，装错了字符系统，显示就会乱了套。这怎么办？就在这时，一个叫*ISO（国际标谁化组织）的国际组织*决定着手解决这个问题。他们采用的方法很简单：**废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它“Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”**。

UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 **ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于 ascii 里的那些”半角”字符，UNICODE 保持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码**。由于”半角”英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。

但是，**UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容**，这使得 GBK 与 UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。**UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535(2^16)种不同的字符**，这大概已经可以覆盖世界上所有文化的符号。

UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是**面向传输的众多 UTF（UCS Transfer Format）标准**出现了，顾名思义，**UTF8就是每次8个位传输数据，而UTF16就是每次16个位**，只不过为了传输时的可靠性，从 UNICODE 到 UTF 时并不是直接的对应，而是要过一些算法和规则来转换。

看完这些，相信你对于这几个编码关系等，了解的比较清楚了吧。我再来简单的总结一下：
* 中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。
* 汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。
* 中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。
* 每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。
* 终于，有个叫 ISO 的组织看不下去了。他们一起创造了一种编码 UNICODE ，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有 UNICODE 这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。
* UNICODE在网络传输中，出现了两个标准 UTF-8 和 UTF-16，分别每次传输 8个位和 16个位。

于是就会有人产生疑问，UTF-8 既然能保存那么多文字、符号，为什么国内还有这么多使用 GBK 等编码的人？因为 UTF-8 等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。但是目前的电脑来看，硬盘都是白菜价，电脑性能也已经足够无视这点性能的消耗了。**所以推荐所有的网页使用统一编码：UTF-8**。


### 关于记事本无法单独保存“联通”的问题,由此引出 “BOM头”

当你新建一个 文本文档 之后，在里面输入 “联通” 两个字，然后保存。当你再次打开的时候，原来输入的 “联通” 会变成两个乱码。

<div align="center"><img src="{{ "/images/otherCharacterEncoding/1.png" | prepend: site.baseurl }}" width="300" /></div>

这个问题就是因为 GB2312 编码与 UTF8 编码产生了编码冲撞造成的。从网上引来一段从UNICODE到UTF8的转换规则：

|----------------+----------------------------------------|
| UNICODE        | UTF-8                                  |
|:--------------:|:--------------------------------------:|
| 0000 – 007F    | 0xxxxxxx （1字节模板）                  |
|----------------+----------------------------------------|
| 0080 – 07FF    | 110xxxxx 10xxxxxx （2字节模板）         |
|----------------+----------------------------------------|
| 0800 – FFFF    | 1110xxxx 10xxxxxx 10xxxxxx （3字节模板）|
|----------------+----------------------------------------|

例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。

而当你新建一个文本文件时，记事本的编码默认是ANSI, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，“联通”的内码是：

c1 1100 0001

aa 1010 1010

cd 1100 1101

a8 1010 1000

**注意到了吗？**第一二个字节、第三四个字节的起始部分的都是“110”和“10”，正好与UTF8规则里的两字节模板是一致的，于是再次打开记事本 时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001 101010″，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010″，不好意思，这是UNICODE的006A，也就是小写的字母“j”，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。

由这个问题，可以发散出很多问题。比较常见的一个问题就是：我已经把文件保存成了 XX 编码，为什么每次打开，还是原来的 YY 编码？！原因就在于此，你虽然保存成了 XX 编码，但是系统识别的时候，却误识别为了 YY 编码，所以还是显示为 YY 编码。**为了避免这个问题，微软公司弄出了一个叫BOM头的东西**。

### 关于文件 BOM 头的问题

当使用类似 WINDOWS 自带的记事本等软件，**在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）**。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。这样就可以避免这个问题了。对于一般的文件，这样并不会产生什么麻烦。

这样做，也有弊处，尤其体现在网页中。PHP并不会忽略BOM，所以在读取、包含或者引用这些文件时，会把BOM作为该文件开头正文 的一部分。根据嵌入式语言的特点，这串字符将被直接执行（显示）出来。由此造成即使页面的 top padding 设置为0，也无法让整个网页紧贴浏览器顶部，因为在html一开头有这3个字符。如果你在网页中，发现了由未知的空白等，很有可能就是由于文件有 BOM 头造成的。遇到这种问题，把文件保存的时候，不要带有 BOM 头！

### 如何查看和修改某文档的编码

* **直接使用记事本查看和修改**。我们可以用记事本打开文件，然后点击左上角的 “文件” =》“另存为”，这时候就会弹出一个保存的窗口。在下面选择好编码之后，点击保存就可以了。

<div align="center"><img src="{{ "/images/otherCharacterEncoding/2.png" | prepend: site.baseurl }}" width="500" /></div>

&nbsp;&nbsp;但是这种方式的选择余地非常小，通常用来快速查看文件是什么编码。我更推荐使用下面的方法。

* **使用其他文本编辑器（例如：notepad ++）来查看修改**。几乎所有的成熟的文本编辑器（例如：Dreamweaver、Emeditor等），都可以快速查看或修改文件编码。这一点尤其体现在 notepad++ 上面。

&nbsp;&nbsp;打开一个文件之后，会在右下角显示当前文件的编码。

<div align="center"><img src="{{ "/images/otherCharacterEncoding/3.png" | prepend: site.baseurl }}" width="400" /></div>

&nbsp;&nbsp;点击上面菜单栏中的 “encoding” 即可把当前文档转换成其他编码

<div align="center"><img src="{{ "/images/otherCharacterEncoding/4.png" | prepend: site.baseurl }}" width="400" /></div>

### 计算机程序设计中中文文本编码解析

看完上面的内容，我想大家对计算机编码及其发展应该有了一个清晰的认识，下面我们来看一下如何解析一个中文的文本文件，由于中文编码有许多格式，为了方便解析一个中文文件，在文件头往往会包含一个编码格式的标示，这就是BOM（Byte Order Mark），对于不同的编码，其对应的BOM不同：

UTF-8：0xEF BB BF

UTF-16(BE)：0xFE FF

UTF-16(LE)：0xFF FE

上面的BE和LE表示大端(big edian)和小端(little edian)格式，它们是CPU处理多字节数的不同方式。例如“汉”字的Unicode编码是6C49。那么写到文件里时，究竟是将6C(高字节)写在前面，还是将49(低字节)写在前面？如果将6C写在前面，就是big endian。如果将49写在前面，就是little endian。也就是说“高字节”写在“低地址”就是大端，“低字节”写在“低地址”就是小端。

对于有BOM的文件，我们知道其编码格式就很容易解析，对于没有BOM的文件，我们又如何判断该文件是UTF-8还是GBK码呢？在网上找了很久都没找到现成的代码，于是自己去查了一下UTF-8具体的编码格式，如下：

<div align="center"><img src="{{ "/images/otherCharacterEncoding/5.png" | prepend: site.baseurl }}" width="600" /></div>

在ASCII码的范围，用一个字节表示，超出ASCII码的范围就用字节表示，这就形成了我们上面看到的UTF-8的表示方法，这様的好处是当UNICODE文件中只有ASCII码时，存储的文件都为一个字节，所以就是普通的ASCII文件无异，读取的时候也是如此，所以能与以前的ASCII文件兼容。

大于ASCII码的，就会由上面的第一字节的前几位表示该unicode字符的长度，比如110xxxxxx前三位的二进制表示告诉我们这是个2BYTE的UNICODE字符；1110xxxx是个三位的UNICODE字符，依此类推；xxx的位置由字符编码数的二进制表示的位填入，依次从右向左填入该字符对应的Unicode编码，左边多出的补0。越靠右的x具有越少的特殊意义。只用最短的那个足够表达一个字符编码数的多字节串。注意在多字节串中，第一个字节的开头"1"的数目就是整个串中字节的数目。

**ASCII码占一个字节；GB2312和GBK码英文字符占一个字节，中文字符占2个字节；UTF-8编码下字符所占字节数从1到6个不等，英文字符占一个字节，中文字符通常占3个字节。**